{
  "version": 3,
  "sources": ["../src/index.ts", "../src/codecs.ts", "../src/url.ts", "../src/resource.ts", "../src/utils.ts", "../src/onnx.ts", "../src/schema.ts", "../package.json", "../src/inference.ts"],
  "sourcesContent": ["export default removeBackground;\nexport {\n  removeBackground,\n  removeForeground,\n  segmentForeground,\n  applySegmentationMask\n};\nexport type { Config, ImageSource };\n\nimport lodash from 'lodash';\nimport ndarray from 'ndarray';\nimport { initInference, runInference } from './inference';\nimport { Config, validateConfig } from './schema';\nimport * as utils from './utils';\nimport { ImageSource } from './utils';\n\nconst { memoize } = lodash;\nconst init = memoize(initInference, (config) => JSON.stringify(config));\n\n/**\n * Removes the background from an image.\n *\n * @param image - The image to remove the background from.\n * @param configuration - Optional configuration for the background removal process.\n * @returns A Promise that resolves to the resulting image with the background removed.\n */\nasync function removeBackground(\n  image: ImageSource,\n  configuration?: Config\n): Promise<Blob> {\n  const { config, session } = await init(configuration);\n\n  const imageTensor = await utils.imageSourceToImageData(image, config);\n  const [width, height, channels] = imageTensor.shape;\n\n  const alphamask = await runInference(imageTensor, config, session);\n  const stride = width * height;\n\n  const outImageTensor = imageTensor;\n  for (let i = 0; i < stride; i += 1) {\n    outImageTensor.data[4 * i + 3] = alphamask.data[i];\n  }\n\n  const outImage = await utils.imageEncode(\n    outImageTensor,\n    config.output.quality,\n    config.output.format\n  );\n\n  return outImage;\n}\n\n/**\n * Removes the foreground from an image.\n *\n * @param image - The image to remove the foreground from.\n * @param configuration - Optional configuration for the foreground removal process.\n * @returns A Promise that resolves to the resulting image with the foreground removed.\n */\nasync function removeForeground(\n  image: ImageSource,\n  configuration?: Config\n): Promise<Blob> {\n  const { config, session } = await init(configuration);\n\n  const imageTensor = await utils.imageSourceToImageData(image, config);\n  const [width, height, channels] = imageTensor.shape;\n\n  const alphamask = await runInference(imageTensor, config, session);\n  const stride = width * height;\n  const outImageTensor = imageTensor;\n  for (let i = 0; i < stride; i += 1) {\n    outImageTensor.data[4 * i + 3] = 255 - alphamask.data[i];\n  }\n\n  const outImage = await utils.imageEncode(\n    outImageTensor,\n    config.output.quality,\n    config.output.format\n  );\n\n  return outImage;\n}\n\n/**\n * Segments the foreground of an image using a given configuration.\n *\n * @param image - The image source to segment.\n * @param configuration - The optional configuration for the segmentation.\n * @returns A Promise that resolves to the segmented foreground as a Blob.\n */\nasync function segmentForeground(\n  image: ImageSource,\n  configuration?: Config\n): Promise<Blob> {\n  const { config, session } = await init(configuration);\n\n  const imageTensor = await utils.imageSourceToImageData(image, config);\n  const [height, width, channels] = imageTensor.shape;\n\n  const alphamask = await runInference(imageTensor, config, session);\n  const stride = width * height;\n\n  if (config.output.format === 'image/x-alpha8') {\n    const outImage = await utils.imageEncode(\n      alphamask,\n      config.output.quality,\n      config.output.format\n    );\n    return outImage;\n  } else {\n    const outImageTensor = ndarray(new Uint8Array(channels * stride), [\n      height,\n      width,\n      channels\n    ]);\n    for (let i = 0; i < stride; i += 1) {\n      const index = 4 * i + 3;\n      outImageTensor.data[index] = alphamask.data[i]; //Red\n      outImageTensor.data[index + 1] = alphamask.data[i]; //Green\n      outImageTensor.data[index + 2] = alphamask.data[i]; // Blue\n      outImageTensor.data[index + 3] = 255;\n    }\n\n    const outImage = await utils.imageEncode(\n      outImageTensor,\n      config.output.quality,\n      config.output.format\n    );\n\n    return outImage;\n  }\n}\n\nasync function applySegmentationMask(\n  image,\n  mask,\n  config?: Config\n): Promise<Blob> {\n  config = validateConfig(config);\n  const imageTensor = await utils.imageSourceToImageData(image, config);\n  const [imageHeight, imageWidth, imageChannels] = imageTensor.shape;\n  const maskTensor = await utils.imageSourceToImageData(mask, config);\n  const [maskHeight, maskWidth, maskChannels] = maskTensor.shape;\n\n  const alphaMask =\n    maskHeight !== imageHeight || maskWidth !== imageWidth\n      ? utils.tensorResizeBilinear(maskTensor, imageWidth, imageHeight)\n      : maskTensor;\n  const stride = imageWidth * imageHeight;\n  for (let i = 0; i < stride; i += 1) {\n    const idxImage = imageChannels * i;\n    const idxMask = maskChannels * i;\n    imageTensor.data[idxImage + 3] = alphaMask.data[idxMask]; // alpha information it always in the first (sometimes also in the others)\n  }\n\n  const outImage = await utils.imageEncode(\n    imageTensor,\n    config.output.quality,\n    config.output.format\n  );\n\n  return outImage;\n}\n", "export { imageEncode, imageDecode, MimeType };\n\nimport sharp, { FormatEnum } from 'sharp';\nimport ndarray, { NdArray } from 'ndarray';\n\nasync function imageDecode(blob: Blob): Promise<NdArray<Uint8Array>> {\n  const buffer = await blob.arrayBuffer();\n\n  const mime = MimeType.fromString(blob.type);\n  switch (mime.type) {\n    case 'image/x-alpha8': {\n      const width = parseInt(mime.params['width']);\n      const height = parseInt(mime.params['height']);\n      return ndarray(new Uint8Array(await blob.arrayBuffer()), [\n        height,\n        width,\n        1\n      ]);\n    }\n    case 'image/x-rgba8': {\n      const width = parseInt(mime.params['width']);\n      const height = parseInt(mime.params['height']);\n      return ndarray(new Uint8Array(await blob.arrayBuffer()), [\n        height,\n        width,\n        4\n      ]);\n    }\n    case 'application/octet-stream':\n    case `image/png`:\n    case `image/jpeg`:\n    case `image/webp`: {\n      const decoded = sharp(buffer);\n      let { width, height, channels } = await decoded.metadata();\n\n      if (channels === 3) {\n        decoded.ensureAlpha();\n        channels = 4;\n      }\n\n      const outBuffer = await decoded.raw().toBuffer();\n      const array = ndarray(outBuffer, [height!, width!, channels!]);\n      await sharp(array.data, {\n        raw: { width: width!, height: height!, channels: channels! }\n      });\n      return array;\n    }\n    default:\n      throw new Error(`Unsupported format: ${mime.type}`);\n  }\n}\n\nasync function imageEncode(\n  imageTensor: NdArray<Uint8Array>,\n  quality: number = 0.8,\n  type: string = 'image/png'\n): Promise<Blob> {\n  const [height, width, channels] = imageTensor.shape;\n  if (channels !== 4) throw new Error('Only 4-channel images are supported');\n  const image = sharp(imageTensor.data, { raw: { height, width, channels } });\n  type Keys = keyof FormatEnum;\n\n  switch (type) {\n    case 'image/x-alpha8':\n    case 'image/x-rgba8': {\n      const mime = MimeType.create(type, {\n        width: width.toString(),\n        height: height.toString()\n      });\n      return new Blob([imageTensor.data], { type: mime.toString() });\n    }\n    case `image/png`:\n    case `image/jpeg`:\n    case `image/webp`:\n      const format = type.split('/').pop()! as Keys;\n      const buffer = await image\n        .toFormat(format, { quality: quality * 100 })\n        .toBuffer();\n      return new Blob([buffer], { type: type });\n    default:\n      throw new Error(`Invalid format: ${format}`);\n  }\n}\n\nclass MimeType {\n  type: string = 'application/octet-stream';\n  params: Record<string, string> = {};\n\n  private constructor(type: string, params: Record<string, string>) {\n    this.type = type;\n    this.params = params;\n  }\n\n  toString(): string {\n    const paramsStr = [];\n    for (const key in this.params) {\n      const value = this.params[key];\n      paramsStr.push(`${key}=${value}`);\n    }\n    return [this.type, ...paramsStr].join(';');\n  }\n\n  static create(type, params: Record<string, string>): MimeType {\n    return new MimeType(type, params);\n  }\n\n  isIdentical(other: MimeType): Boolean {\n    return this.type === other.type && this.params === other.params;\n  }\n\n  isEqual(other: MimeType): Boolean {\n    return this.type === other.type;\n  }\n\n  static fromString(mimeType: string): MimeType {\n    const [type, ...paramsArr] = mimeType.split(';');\n    const params: Record<string, string> = {};\n\n    for (const param of paramsArr) {\n      const [key, value] = param.split('=');\n      params[key.trim()] = value.trim();\n    }\n    return new MimeType(type, params);\n  }\n}\n", "export { ensureAbsoluteURI };\n\nfunction isAbsoluteURI(url: string): boolean {\n  const regExp = new RegExp('^(?:[a-z+]+:)?//', 'i');\n  return regExp.test(url); // true - regular http absolute URL\n}\n\nfunction ensureAbsoluteURI(url: string, baseUrl: string): URL {\n  if (isAbsoluteURI(url)) {\n    return new URL(url);\n  } else {\n    return new URL(url, baseUrl);\n  }\n}\n", "export { loadAsBlob, loadAsUrl, loadFromURI };\n\nimport { Config } from './schema';\nimport { ensureAbsoluteURI } from './url';\nimport { readFile } from 'fs/promises';\nimport { fileURLToPath } from 'url';\n\nasync function loadAsUrl(url: string, config: Config) {\n  return URL.createObjectURL(await loadAsBlob(url, config));\n}\n\nasync function loadFromURI(\n  uri: URL,\n  config = { headers: { 'Content-Type': 'application/octet-stream' } }\n) {\n  switch (uri.protocol) {\n    case 'http:':\n      return await fetch(uri);\n    case 'https:':\n      return await fetch(uri);\n    case 'file:': {\n      const buffer = await readFile(fileURLToPath(uri));\n      return new Response(buffer, { status: 200, headers: config.headers });\n    }\n    default:\n      throw new Error(`Unsupported protocol: ${uri.protocol}`);\n  }\n}\n\nasync function loadAsBlob(key: string, config: Config) {\n  // load resource metadata\n\n  const resourceUri = ensureAbsoluteURI('./resources.json', config.publicPath);\n\n  const resourceResponse = await loadFromURI(resourceUri);\n\n  if (!resourceResponse.ok) {\n    throw new Error(\n      `Resource metadata not found. Ensure that the config.publicPath is configured correctly.`\n    );\n  }\n  const resourceMap = await resourceResponse.json();\n  const entry = resourceMap[key];\n\n  if (!entry) {\n    throw new Error(\n      `Resource ${key} not found. Ensure that the config.publicPath is configured correctly.`\n    );\n  }\n\n  const chunks = entry.chunks; // list of entries\n\n  let downloadedSize = 0;\n  const responses = chunks.map(async (chunk) => {\n    const url = ensureAbsoluteURI(chunk.hash, config.publicPath);\n    const chunkSize = chunk.offsets[1] - chunk.offsets[0];\n    const response = await loadFromURI(url, {\n      headers: { 'Content-Type': entry.mime }\n    });\n    const blob = await response.blob();\n\n    if (chunkSize !== blob.size) {\n      throw new Error(\n        `Failed to fetch ${key} with size ${chunkSize} but got ${blob.size}`\n      );\n    }\n\n    if (config.progress) {\n      downloadedSize += chunkSize;\n      config.progress(`fetch:${key}`, downloadedSize, entry.size);\n    }\n    return blob;\n  });\n\n  // we could create a new buffer here and use the chunk entries and combine the file instead\n\n  const allChunkData = await Promise.all(responses);\n\n  const data = new Blob(allChunkData, { type: entry.mime });\n  if (data.size !== entry.size) {\n    throw new Error(\n      `Failed to fetch ${key} with size ${entry.size} but got ${data.size}`\n    );\n  }\n  return data;\n}\n", "export {\n  imageDecode,\n  imageEncode,\n  tensorResizeBilinear,\n  tensorHWCtoBCHW,\n  calculateProportionalSize,\n  imageSourceToImageData,\n  ImageSource,\n  convertFloat32ToUint8\n};\n\nimport { Config } from './schema';\nimport * as codecs from './codecs';\nimport { ensureAbsoluteURI } from './url';\nimport { loadFromURI } from './resource';\n\nimport ndarray, { NdArray } from 'ndarray';\nimport { imageDecode, imageEncode } from './codecs';\n\ntype ImageSource =\n  | ArrayBuffer\n  | Uint8Array\n  | Blob\n  | URL\n  | string\n  | NdArray<Uint8Array>;\n\nfunction tensorResizeBilinear(\n  imageTensor: NdArray<Uint8Array>,\n  newWidth: number,\n  newHeight: number\n): NdArray<Uint8Array> {\n  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n  // Calculate the scaling factors\n  const scaleX = srcWidth / newWidth;\n  const scaleY = srcHeight / newHeight;\n\n  // Create a new NdArray to store the resized image\n  const resizedImageData = ndarray(\n    new Uint8Array(srcChannels * newWidth * newHeight),\n    [newHeight, newWidth, srcChannels]\n  );\n  // Perform interpolation to fill the resized NdArray\n  for (let y = 0; y < newHeight; y++) {\n    for (let x = 0; x < newWidth; x++) {\n      const srcX = x * scaleX;\n      const srcY = y * scaleY;\n      const x1 = Math.max(Math.floor(srcX), 0);\n      const x2 = Math.min(Math.ceil(srcX), srcWidth - 1);\n      const y1 = Math.max(Math.floor(srcY), 0);\n      const y2 = Math.min(Math.ceil(srcY), srcHeight - 1);\n\n      const dx = srcX - x1;\n      const dy = srcY - y1;\n\n      for (let c = 0; c < srcChannels; c++) {\n        const p1 = imageTensor.get(y1, x1, c);\n        const p2 = imageTensor.get(y1, x2, c);\n        const p3 = imageTensor.get(y2, x1, c);\n        const p4 = imageTensor.get(y2, x2, c);\n\n        // Perform bilinear interpolation\n        const interpolatedValue =\n          (1 - dx) * (1 - dy) * p1 +\n          dx * (1 - dy) * p2 +\n          (1 - dx) * dy * p3 +\n          dx * dy * p4;\n\n        resizedImageData.set(y, x, c, Math.round(interpolatedValue));\n      }\n    }\n  }\n\n  return resizedImageData;\n}\n\nfunction tensorHWCtoBCHW(\n  imageTensor: NdArray<Uint8Array>,\n  mean: number[] = [128, 128, 128],\n  std: number[] = [256, 256, 256]\n): NdArray<Float32Array> {\n  var imageBufferData = imageTensor.data;\n  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n  const stride = srcHeight * srcWidth;\n  const float32Data = new Float32Array(3 * stride);\n\n  // r_0, r_1, .... g_0,g_1, .... b_0\n  for (let i = 0, j = 0; i < imageBufferData.length; i += 4, j += 1) {\n    float32Data[j] = (imageBufferData[i] - mean[0]) / std[0];\n    float32Data[j + stride] = (imageBufferData[i + 1] - mean[1]) / std[1];\n    float32Data[j + stride + stride] =\n      (imageBufferData[i + 2] - mean[2]) / std[2];\n  }\n\n  return ndarray(float32Data, [1, 3, srcHeight, srcWidth]);\n}\n\nfunction calculateProportionalSize(\n  originalWidth: number,\n  originalHeight: number,\n  maxWidth: number,\n  maxHeight: number\n): [number, number] {\n  const widthRatio = maxWidth / originalWidth;\n  const heightRatio = maxHeight / originalHeight;\n  const scalingFactor = Math.min(widthRatio, heightRatio);\n  const newWidth = Math.floor(originalWidth * scalingFactor);\n  const newHeight = Math.floor(originalHeight * scalingFactor);\n  return [newWidth, newHeight];\n}\n\nasync function imageSourceToImageData(\n  image: ImageSource,\n  _: Config\n): Promise<NdArray<Uint8Array>> {\n  if (typeof image === 'string') {\n    image = ensureAbsoluteURI(image, `file://${process.cwd()}/`);\n  }\n  if (image instanceof URL) {\n    image = await (await loadFromURI(image)).blob();\n  }\n  if (image instanceof ArrayBuffer || ArrayBuffer.isView(image)) {\n    image = new Blob([image]);\n  }\n  if (image instanceof Blob) {\n    image = await codecs.imageDecode(image);\n  }\n\n  return image as NdArray<Uint8Array>;\n}\n\nfunction convertFloat32ToUint8(\n  float32Array: NdArray<Float32Array>\n): NdArray<Uint8Array> {\n  const uint8Array = new Uint8Array(float32Array.data.length);\n  for (let i = 0; i < float32Array.data.length; i++) {\n    uint8Array[i] = float32Array.data[i] * 255;\n  }\n  return ndarray(uint8Array, float32Array.shape);\n}\n", "export { createOnnxSession, runOnnxSession };\n\nimport ndarray, { NdArray } from 'ndarray';\nimport * as ort from 'onnxruntime-node';\n// import * as ort from 'onnxruntime-node-gpu';\nimport { Config } from './schema';\n\nasync function createOnnxSession(model: any, config: Config) {\n  if (config.debug) {\n    ort.env.debug = true;\n    ort.env.logLevel = 'verbose';\n    console.debug('ort.env.wasm:', ort.env.wasm);\n  }\n\n  const ort_config: ort.InferenceSession.SessionOptions = {\n    graphOptimizationLevel: 'all',\n    executionMode: 'parallel'\n  };\n\n  const session = await ort.InferenceSession.create(model, ort_config).catch(\n    (e: any) => {\n      throw new Error(\n        `Failed to create session: ${e}. Please check if the publicPath is set correctly.`\n      );\n    }\n  );\n  return session;\n}\n\nasync function runOnnxSession(\n  session: any,\n  inputs: [string, NdArray<Float32Array>][],\n  outputs: [string]\n) {\n  const feeds: Record<string, any> = {};\n  for (const [key, tensor] of inputs) {\n    feeds[key] = new ort.Tensor(\n      'float32',\n      new Float32Array(tensor.data),\n      tensor.shape\n    );\n  }\n  const outputData = await session.run(feeds, {});\n  const outputKVPairs: NdArray<Float32Array>[] = [];\n\n  for (const key of outputs) {\n    const output: ort.Tensor = outputData[key];\n    const shape: number[] = output.dims as number[];\n    const data: Float32Array = output.data as Float32Array;\n    const tensor = ndarray(data, shape);\n    outputKVPairs.push(tensor);\n  }\n\n  return outputKVPairs;\n}\n", "export { ConfigSchema, Config, validateConfig };\nimport { z } from 'zod';\nimport path from 'node:path';\nimport pkg from '../package.json';\n\nfunction isURI(s: string) {\n  try {\n    new URL(s);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nconst ConfigSchema = z\n  .object({\n    publicPath: z\n      .string()\n      .optional()\n      .describe('The public path to the wasm files and the onnx model.')\n      .default(`file://${path.resolve(`node_modules/${pkg.name}/dist/`)}/`)\n      .transform((val) => {\n        return val\n          .replace('${PACKAGE_NAME}', pkg.name)\n          .replace('${PACKAGE_VERSION}', pkg.version);\n      })\n      .refine((val) => isURI(val), {\n        message: 'String must be a valid uri'\n      }),\n    debug: z\n      .boolean()\n      .default(false)\n      .describe('Whether to enable debug logging.'),\n    proxyToWorker: z\n      .boolean()\n      .default(true)\n      .describe('Whether to proxy inference to a web worker.'),\n    fetchArgs: z\n      .any({})\n      .default({})\n      .describe('Arguments to pass to fetch when loading the model.'),\n    progress: z\n      .function()\n      .args(z.string(), z.number(), z.number())\n      .returns(z.void())\n      .describe('Progress callback.')\n      .optional(),\n    model: z.enum(['small', 'medium', 'large']).default('medium'),\n    output: z\n      .object({\n        format: z\n          .enum([\n            'image/png',\n            'image/jpeg',\n            'image/webp',\n            'image/x-rgba8',\n            'image/x-alpha8'\n          ])\n          .default('image/png'),\n        quality: z.number().default(0.8)\n      })\n      .default({})\n  })\n  .default({});\n\ntype Config = z.infer<typeof ConfigSchema>;\n\nfunction validateConfig(configuration?: Config): Config {\n  const config = ConfigSchema.parse(configuration ?? {});\n  if (config.debug) console.log('Config:', config);\n  if (config.debug && !config.progress) {\n    config.progress =\n      config.progress ??\n      ((key, current, total) => {\n        console.debug(`Downloading ${key}: ${current} of ${total}`);\n      });\n  }\n  return config;\n}\n", "{\n  \"name\": \"@imgly/background-removal-node\",\n  \"version\": \"1.4.5\",\n  \"description\": \"Background Removal in NodeJS\",\n  \"resources\": \"@imgly/background-removal-node\",\n  \"keywords\": [\n    \"background-removal\",\n    \"nodejs\",\n    \"image-segmentation\",\n    \"image-matting\",\n    \"onnx\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/imgly/background-removal-js.git\"\n  },\n  \"license\": \"SEE LICENSE IN LICENSE.md\",\n  \"author\": {\n    \"name\": \"IMG.LY GmbH\",\n    \"email\": \"support@img.ly\",\n    \"url\": \"https://img.ly\"\n  },\n  \"bugs\": {\n    \"email\": \"support@img.ly\"\n  },\n  \"homepage\": \"https://img.ly/showcases/cesdk/web/background-removal\",\n  \"source\": \"./src/index.ts\",\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"require\": \"./dist/index.cjs\",\n      \"import\": \"./dist/index.mjs\",\n      \"types\": \"./dist/index.d.ts\"\n    }\n  },\n  \"files\": [\n    \"LICENSE.md\",\n    \"README.md\",\n    \"CHANGELOG.md\",\n    \"ThirdPartyLicenses.json\",\n    \"dist/\",\n    \"bin/\"\n  ],\n  \"scripts\": {\n    \"start\": \"npm run watch\",\n    \"clean\": \"npx rimraf dist\",\n    \"test\": \"true\",\n    \"resources\": \"node ../../scripts/package-resources.mjs\",\n    \"changelog:create\": \"node ../../scripts/changelog/changelog-create.mjs\",\n    \"changelog:generate\": \"node ../../scripts/changelog/changelog-generate.mjs\",\n    \"build\": \"npm run clean && npm run resources && npm run types && npm run changelog:generate && node scripts/build.mjs\",\n    \"types\": \" npx tsc --declaration --emitDeclarationOnly --declarationDir dist --declarationMap\",\n    \"watch\": \"npm run clean && npm run resources && npm run changelog:generate && node scripts/watch.mjs\",\n    \"lint\": \"npx prettier --write .\",\n    \"publish:latest\": \"npm run build && npm publish --tag latest --access public\",\n    \"publish:next\": \"npm run build && npm publish --tag next --access public\",\n    \"package:pack\": \"npm run build && npm pack . --pack-destination ../../releases\"\n  },\n  \"dependencies\": {\n    \"onnxruntime-node\": \"~1.17.0\",\n    \"sharp\": \"~0.32.4\",\n    \"@types/lodash\": \"~4.14.195\",\n    \"@types/node\": \"~20.3.1\",\n    \"@types/ndarray\": \"~1.0.14\",\n    \"lodash\": \"~4.17.21\",\n    \"ndarray\": \"~1.0.19\",\n    \"zod\": \"~3.21.4\"\n  },\n  \"devDependencies\": {\n    \"assert\": \"~2.0.0\",\n    \"esbuild\": \"~0.18.18\",\n    \"npm-dts\": \"~1.3.12\",\n    \"os-browserify\": \"~0.3.0\",\n    \"path-browserify\": \"~1.0.1\",\n    \"process\": \"~0.11.10\",\n    \"stream-browserify\": \"~3.0.0\",\n    \"ts-loader\": \"~9.4.3\",\n    \"tslib\": \"~2.5.3\",\n    \"typescript\": \"~5.1.6\",\n    \"util\": \"~0.12.5\",\n    \"webpack\": \"~5.85.1\",\n    \"webpack-cli\": \"~5.1.4\"\n  }\n}", "export { initInference, runInference };\n\nimport { tensorResizeBilinear, tensorHWCtoBCHW } from './utils';\nimport { createOnnxSession, runOnnxSession } from './onnx';\nimport { Config, validateConfig } from './schema';\n\nimport { loadAsBlob } from './resource';\nimport ndarray, { NdArray } from 'ndarray';\nimport { convertFloat32ToUint8 } from './utils';\n\nasync function initInference(config?: Config) {\n  config = validateConfig(config);\n\n  if (config.debug) console.debug('Loading model...');\n  const model = config.model;\n  const blob = await loadAsBlob(`/models/${model}`, config);\n  const arrayBuffer = await blob.arrayBuffer();\n  const session = await createOnnxSession(arrayBuffer, config);\n  return { config, session };\n}\n\nasync function runInference(\n  imageTensor: NdArray<Uint8Array>,\n  config: Config,\n  session: any\n): Promise<NdArray<Uint8Array>> {\n  if (config.progress) config.progress('compute:inference', 0, 1);\n  const resolution = 1024;\n  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n\n  let tensorImage = tensorResizeBilinear(imageTensor, resolution, resolution);\n  const inputTensor = tensorHWCtoBCHW(tensorImage); // this converts also from float to rgba\n\n  // run\n  const predictionsDict = await runOnnxSession(\n    session,\n    [['input', inputTensor]],\n    ['output']\n  );\n\n  let alphamask = ndarray(predictionsDict[0].data, [resolution, resolution, 1]);\n  let alphamaskU8 = convertFloat32ToUint8(alphamask);\n  alphamaskU8 = tensorResizeBilinear(alphamaskU8, srcWidth, srcHeight);\n\n  if (config.progress) config.progress('compute:inference', 1, 1);\n  return alphamaskU8;\n}\n"],
  "mappings": "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",
  "names": ["import_ndarray", "ndarray", "sharp", "import_url", "import_ndarray", "ndarray", "ndarray", "import_ndarray", "ndarray", "path", "import_ndarray", "ndarray", "lodash", "ndarray"]
}
